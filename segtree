struct item{
  
};
struct segtree{
  ll size;
  vector<item> values;
  item N_Neutral={};
  item merge(item a,item b){
   
  }
  item single(ll v){
    
  }
  void init(ll n){
    size=1;
    while(size<n) size*=2;
    values.resize(2*size,N_Neutral);
  }
  void build(vl &v,ll x,ll lx, ll rx){
    if(rx-lx==1){
      if(lx<(ll)v.size()) {
          values[x]=single(v[lx]);        
      }
      return;
    }
    ll m=(lx+rx)/2;
    build(v,2*x+1,lx,m);
    build(v,2*x+2,m,rx);
    values[x]=merge(values[2*x+1],values[2*x+2]);
  }
  void build(vl &v){
    build(v,0,0,size);
  }
  void set(ll i,ll v,ll x,ll lx,ll rx){
    if(rx-lx==1){
      values[x]=single(v);
      return;
    }
    ll m=(lx+rx)/2;
    if(i<m) set(i,v,2*x+1,lx,m);
    else set(i,v,2*x+2,m,rx);
    values[x]=merge(values[2*x+1],values[2*x+2]);
  }
  void set(ll i,ll v){
    set(i,v,0,0,size);
  }
  item calc(ll l,ll r,ll x, ll lx, ll rx){
    if(rx<=l||lx>=r) return N_Neutral;
    if(lx>=l&&rx<=r) return values[x];
    ll m=(lx+rx)/2;
    item item1=calc(l,r,2*x+1,lx,m);
    item item2=calc(l,r,2*x+2,m,rx);
    return merge(item1,item2);
  }
  item calc(ll l,ll r){
    return calc(l,r,0,0,size);
  }
};
